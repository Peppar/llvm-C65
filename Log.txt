Got this error while debugging my tablegen files:

llvm-tblgen: /home/peppar/clang/llvm/utils/TableGen/CodeGenDAGPatterns.h:646: llvm::Record *llvm::DAGInstruction::getResult(unsigned int) const: Assertion `RN < Results.size()' failed.



/home/peppar/clang/llvm/lib/Target/C65/C65InstrInfo.td:183:5: error: In ASLa: Could not infer all types in pattern!

Changed the immediate 1 to (i8 i)... Don't really know what this will yield..!


Added C65 to these files
  /home/peppar/clang/llvm/include/llvm/ADT/Triple.h
  /home/peppar/clang/llvm/lib/Support/Triple.cpp


Removed other targets from 

~/clang/build/include/llvm/Config/Targets.def

 LLVM_TARGET(R600) LLVM_TARGET(SystemZ) LLVM_TARGET(Hexagon) LLVM_TARGET(NVPTX) LLVM_TARGET(CppBackend) LLVM_TARGET(MSP430) LLVM_TARGET(XCore) LLVM_TARGET(Mips) LLVM_TARGET(AArch64) LLVM_TARGET(ARM) LLVM_TARGET(PowerPC) LLVM_TARGET(Sparc) 

ISel is required for CLANG to work.

Every directory needs a Makefile, CMakeLists.txt and
LLVMBuild.txt. Changes to these files are taken into account without
re-running config

These files need to be updated manually or by re-running config, if you
added support for an AsmPrinter, AsmParser, Disassembler or if you
want to change the targets to make:

LLVM_ASM_PRINTER(C65)
~/clang/build/include/llvm/Config/AsmPrinters.def
AsmParsers.def
Disassemblers.def
Targets.def

Added -p:16:16- to data layout, default is 64-bits, and this generated
i64 = GlobalAddress i16, which didn't really work!


http://lists.cs.uiuc.edu/pipermail/llvmdev/2009-April/021831.html

Pat<A,B> simply means "replace A by B" in the DAG. It is useful if you
have more than one pattern for a single instruction, or if you want to
use multiple instructions in a pattern replacement.

C65TargetLowering was changed to use TargetLoweringObjectFileELF()
purely, and not through its own class that didn't implement any
new functionality anyway...

TODO: Add DEBUG_TYPE to all files
TODO: Make consistent "header comments"
TODO: Make consistent all other comments...
TODO: Define what "bare-bones" means...
* No jumps, no parameters, no return values
* no stack frame
* global variables
* no X, no Y
* only boolean functions ORA, EOR, AND...
* no push, pull
* no awareness of stack pointer, PC

IMPORTANT: tried to use timm: class instead of imm: class, and then
the compiler didn't make use of my immediate instructions anymore..!!

Modifs:
  ~/llvm/lib/Target/LLVMBuild.txt
    : added C65 to subdirectories in [common]
  ~/llvm/tools/clang/lib/Basic/Targets.cpp
  /home/peppar/llvm/configure
  /home/peppar/llvm/CMakeLists.txt
    : added C65 to all targets

Not modifs:
// ~/llvm/tools/clang/include/clang/Basic/TargetBuiltins.h
// ~/llvm/tools/clang/Basic/BuiltinsC65.def
// ~/llvm/tools/clang/lib/Driver/Driver.cpp
// ~/llvm/tools/clang/lib/Driver/ToolChains.cpp
// ~/llvm/tools/clang/lib/Driver/ToolChains.h
// ~/llvm/tools/clang/lib/Driver/Tools.cpp
// ~/llvm/tools/clang/lib/Driver/Tools.h

// /home/peppar/llvm/tools/clang/lib/CodeGen/TargetInfo.cpp
// Seems to have a default..
// /home/peppar/llvm/bindings/python/llvm/disassembler.py
// Do not have a disassembler
// /home/peppar/llvm/docs/CompilerWriterInfo.rst


Modifying instructions with Select(..) in C65ISelDAGToDAG: Force
spilling of one of the operators to AND, SUB, OR, etc..  Inserted
store followed by load, using target-independent types, led to the
LOAD being consumed while the STORE left target-indepdendent. This is
because, in Select(..) as well as in patterns, the resulting DAG must
not include target-independent nodes.

The target-independent load was consumed because it appears on the
left hand side of many instruction patterns, and is selected by the
TableGen generated SelectCode function.


BREAKING REVELATION: Instruction selection process totally destroys my
instructions, and this is due to mal-formed instruction
definitions. For example, the register-to-register move instruction
MOVzz is defined as follows:

class MOVzz<RegisterClass RC, ValueType Ty>
  : ZPInstr<(outs RC:$dst), (ins RC:$src), ";MOV $dst,$src",
            [(set RC:$dst, RC:$src)]>;

However, the instruction matches fails completely to compile this, so
all of my arithmetic functions match it...

How I found out: The compiled instruction selection process can be
found in XXXGenDAGISel.inc under /build/lib/Target/XXX/

Follow the indices to see what happens to your instruction:

ISEL: Starting
pattern match on root node: 0x2acae40: i16 = or 0x2aca918, 0x2acab28
[ORD=5] [ID=7]

  Skipped scope entry (due to false predicate) at index 2, continuing at 30
  Skipped scope entry (due to false predicate) at index 31, continuing at 131
  Skipped scope entry (due to false predicate) at index 132, continuing at 194
  Skipped scope entry (due to false predicate) at index 195, continuing at 214
  Skipped scope entry (due to false predicate) at index 215, continuing at 258
  Skipped scope entry (due to false predicate) at index 259, continuing at 271
  TypeSwitch[i16] from 273 to 286
  Morphed node: 0x2acae40: i16 = MOV16zz 0x2acae40 [ORD=5]


OH WHY:
Do I remember failing to use A directly, when X86 can use CL directly?

// SDNode - shl
// ValueType - i64
// RCClass - I64Regs
// Operand - simm130p

Input list item (ins i16imm:$imm) needs as pattern:
  (i16 imm:$imm)
  and not: i16imm:$imm

Data*bitsDirective are MANDATORY, must not be nullptr, if you are ever
to output the corresponding size. It will NOT default to several
smaller. And the errors aren't helpful.
