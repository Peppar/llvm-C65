//===-- C65ISelDAGToDAG.cpp - A dag to dag inst selector for C65 ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the C65 target.
//
//===----------------------------------------------------------------------===//

#include "C65TargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "c65-isel-dag-to-dag"

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
/// C65DAGToDAGISel - C65 specific code to select C65 machine
/// instructions for SelectionDAG operations.
///
namespace {
class C65DAGToDAGISel : public SelectionDAGISel {
  /// Subtarget - Keep a pointer to the C65 Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  ///
  const C65Subtarget &Subtarget;
  C65TargetMachine &TM;
public:
  explicit C65DAGToDAGISel(C65TargetMachine &tm)
    : SelectionDAGISel(tm),
      Subtarget(tm.getSubtarget<C65Subtarget>()),
      TM(tm) {
  }

  bool IsSimpleNode(SDValue N) const;
  SDValue SpillValue(SDValue N, SDLoc DL);

  SDNode *Select(SDNode *N) override;

  // Complex pattern selectors
  bool SelectAddrZP(SDValue N, SDValue &Addr);
  bool SelectAddrZY(SDValue N, SDValue &Base, SDValue &Offset);
  bool SelectAddrXY(SDValue N, SDValue &Base, SDValue &Offset);
  bool SelectAddrS(SDValue N, SDValue &Base, SDValue &Offset);

  /// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
  /// inline asm expressions.
  ///
  bool SelectInlineAsmMemoryOperand(const SDValue &Op,
                                    char ConstraintCode,
                                    std::vector<SDValue> &OutOps) override;

  const char *getPassName() const override {
    return "C65 DAG->DAG Pattern Instruction Selection";
  }

  // Include the pieces autogenerated from the target description.
#include "C65GenDAGISel.inc"
};
}  // end anonymous namespace

/// Select address for imm8+S
///
bool C65DAGToDAGISel::SelectAddrS(SDValue Addr, SDValue &Base,
                                  SDValue &Offset) {
  // Allow only frame indices with S indexing
  FrameIndexSDNode *FIN = nullptr;
  if ((FIN = dyn_cast<FrameIndexSDNode>(Addr))) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
    Offset = CurDAG->getTargetConstant(0, MVT::i8);
    return true;
  }
  if (Addr.getOpcode() == ISD::ADD) {
    ConstantSDNode *CN = nullptr;
    if ((FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) &&
        (CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) &&
        (isInt<8>(CN->getSExtValue()))) {
      // Constant positive word offset from frame index
      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
      Offset = CurDAG->getTargetConstant(CN->getSExtValue(), MVT::i8);
      return true;
    }
  }
  return false;
}

/// Select address for zero page, imm8
///
bool C65DAGToDAGISel::SelectAddrZP(SDValue Addr, SDValue &Offset) {
  ConstantSDNode *CN;
  if ((CN = dyn_cast<ConstantSDNode>(Addr)) &&
      isInt<8>(CN->getSExtValue())) {
    Offset = Addr.getOperand(0);
  }
  return false;
}

/// Select address for ZR+Y
///
bool C65DAGToDAGISel::SelectAddrZY(SDValue Addr, SDValue &Z, SDValue &Y) {
  if (Addr.getOpcode() == ISD::ADD) {
    Z = Addr.getOperand(0);
    Y = Addr.getOperand(1);
    return true;
  }
  return false;
}

/// Select address for imm16+X and imm16+Y
///
bool C65DAGToDAGISel::SelectAddrXY(SDValue Addr, SDValue &Base,
                                   SDValue &Offset) {
  if (Addr.getOpcode() == ISD::FrameIndex ||
      Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetGlobalTLSAddress) {
    return false;
  }
  if (Addr.getOpcode() == ISD::ADD) {
    ConstantSDNode *CN;
    if ((CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) &&
         isInt<16>(CN->getSExtValue())) {
      FrameIndexSDNode *FIN;
      if ((FIN =
	   dyn_cast<FrameIndexSDNode>(Addr.getOperand(0)))) {
          // Constant offset from frame ref.
	return false;
      } else {
	Base = Addr.getOperand(0);
      }
      Offset = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i16);
      return true;
    }
  }
  return false;
}

bool C65DAGToDAGISel::IsSimpleNode(SDValue N) const {
  return N.getOpcode() == ISD::LOAD ||
         N.getOpcode() == ISD::Constant;
}

/// Insert a load and a store to the stack frame for the specified
/// SDValue
///
// SDValue C65DAGToDAGISel::SpillValue(SDValue N, SDLoc DL) {
//   EVT PtrVT = TM.getTargetLowering()->getPointerTy();
//   MVT NVT = N->getSimpleValueType(0);
//   MachineFunction &MF = CurDAG->getMachineFunction();
//   MachineFrameInfo *MFI = MF.getFrameInfo();

//   unsigned Size = NVT.getSizeInBits() / 8;

//   int FI = MFI->CreateSpillStackObject(Size, 1);

//   SDValue FIN = CurDAG->getFrameIndex(FI, PtrVT);
//   SDValue Offset = CurDAG->getConstant(0, PtrVT);

//   SmallVector<SDValue, 4> Args;
//   Args.push_back(N);
//   Args.push_back(FIN);
//   Args.push_back(Offset);
//   Args.push_back(CurDAG->getEntryNode());

//   SDNode *Store = CurDAG->getMachineNode(C65::STAis, DL, MVT::Other, Args);

//   //SDValue Load = DAG.getMachineNode(C65::LDAis, DL, NVT, FIN,
//   //                                  CurDAG->getEntryNode());

//   // SDValue Store = CurDAG->getStore(CurDAG->getEntryNode(), DL, N, FIN,
//   //                                  MachinePointerInfo::getFixedStack(FI),
//   //                                  false, false, false, 0);

//   //  CurDAG->viewGraph();

//   Store->dump();

//   SDValue(Store, 0).dump();

//   SDValue Load = CurDAG->getLoad(NVT, DL, SDValue(Store, 0), FIN,
//                                  MachinePointerInfo::getFixedStack(FI),
//                                  false, false, false, 0);

//   return Load;
// }

SDNode *C65DAGToDAGISel::Select(SDNode *N) {
  MVT NVT = N->getSimpleValueType(0);
  SDLoc DL(N);
  //  C65InstInfo *II = TM.getInstrInfo();

  if (N->isMachineOpcode()) {
    N->setNodeId(-1);
    return nullptr;   // Already selected.
  }

  // Insert register-spilling...
  switch (N->getOpcode()) {
  // case ISD::ADD:
  // case ISD::SUB:
  // case ISD::AND:
  // case ISD::OR:
  // case ISD::XOR: {
  //   // If both operands are complex, then spill one of them to the stack frame
  //   SDValue N0 = N->getOperand(0);
  //   SDValue N1 = N->getOperand(1);
  //   DEBUG({
  //     dbgs() << "MATCH AND/OR/XOR: ";
  //     N->dump();
  //     N0.dump();
  //     N1.dump();
  //   });
  //   if (!IsSimpleNode(N1)) {
  //     //      SDValue Store = CurDAG->getStore(Chain, DL,
  //     //      N->getOperand(1), FI, MMO); SDValue Load =
  //     //      CurDAG->getLoad(ISD::UNINDEXED, ISD::NON_EXTLOAD, DL,
  //     //      MVT, Chain, FI, Undef, NVT, DL, Chain, FI, MMO); SDValue
  //     //      NewVal0 = CurDAG->getConstant(123, NVT); SDValue NewVal1
  //     //      = CurDAG->getConstant(456, NVT);
  //     //      CurDAG->viewGraph();

  // // EVT PtrVT = TM.getTargetLowering()->getPointerTy();
  // // MVT NVT = N->getSimpleValueType(0);
  // // MachineFunction &MF = CurDAG->getMachineFunction();
  // // MachineFrameInfo *MFI = MF.getFrameInfo();

  // // unsigned Size = NVT.getSizeInBits() / 8;

  // // int FI = MFI->CreateSpillStackObject(Size, 1);
  // // SDValue FIN = CurDAG->getFrameIndex(FI, PtrVT);

  // // SDValue Store = CurDAG->getStore(CurDAG->getEntryNode(), DL, N1, FIN,
  // //                                  MachinePointerInfo::getFixedStack(FI),
  // //                                  false, false, false, 0);

  // // Store = SelectCode(Store.getNode());

  // // SDValue Load = CurDAG->getLoad(NVT, DL, Store, FIN,
  // //                                MachinePointerInfo::getFixedStack(FI),
  // //                                false, false, false, 0);

  // // Load = SelectCode(Load.getNode());

  //     SDValue Load = SpillValue(N1, DL);

  //     // SDValue FI = CurDAG->CreateStackTemporary(NVT, 1);
  //     // int Index = FI.getNode->
  //     // unsigned ByteSize = NVT.getSizeInBits() / 8;
  //     // MachineMemOperand *MMO;

  //     // MMO = DAG.getMachineFunction()
  //     //         .getMachineMemOperand(MachinePointerInfo::getFixedStack(FI),
  //     //                               MachineMemOperand::MOStore, ByteSize);

  //     // SDValue Store = CurDAG->getStore(N1, DL, N1, FI, MMO);

  //     // MMO = DAG.getMachineFunction()
  //     //         .getMachineMemOperand(MachinePointerInfo::getFixedStack(FI),
  //     //                               MachineMemOperand::MOLoad, ByteSize);

  //     // SDValue Load = CurDAG->getLoad(NVT, DL, Store, FI, MMO);

  //     //      CurDAG->viewGraph();

  //     CurDAG->UpdateNodeOperands(N, N0, Load);

  //     //      CurDAG->viewGraph();
  //   }
  // } break;
  default: break;
  }

  return SelectCode(N);
}


/// SelectInlineAsmMemoryOperand - Implement addressing mode selection
/// for inline asm expressions.
///
bool
C65DAGToDAGISel::SelectInlineAsmMemoryOperand(const SDValue &Op,
                                              char ConstraintCode,
                                              std::vector<SDValue> &OutOps) {
  // SDValue Op0, Op1;
  // switch (ConstraintCode) {
  // default: return true;
  // case 'm':   // memory
  //  if (!SelectADDRrr(Op, Op0, Op1))
  //    SelectADDRri(Op, Op0, Op1);
  //  break;
  // }

  //OutOps.push_back(Op0);
  //OutOps.push_back(Op1);
  return true;
}

/// createC65ISelDag - This pass converts a legalized DAG into a
/// SPARC-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createC65ISelDag(C65TargetMachine &TM) {
  return new C65DAGToDAGISel(TM);
}
