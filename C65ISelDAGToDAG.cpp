//===-- C65ISelDAGToDAG.cpp - A dag to dag inst selector for C65 ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the C65 target.
//
//===----------------------------------------------------------------------===//

#include "C65TargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "c65-isel-dag-to-dag"

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
/// C65DAGToDAGISel - C65 specific code to select C65 machine
/// instructions for SelectionDAG operations.
///
namespace {
class C65DAGToDAGISel final : public SelectionDAGISel {
  /// Subtarget - Keep a pointer to the C65Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  const C65Subtarget *Subtarget;

public:
  explicit C65DAGToDAGISel(C65TargetMachine &tm)
    : SelectionDAGISel(tm) {}

  const char *getPassName() const override {
    return "C65 DAG->DAG Instruction Selection";
  }

  bool runOnMachineFunction(MachineFunction &MF) override {
    // Reset the subtarget each time through.
    Subtarget = &MF.getSubtarget<C65Subtarget>();
    SelectionDAGISel::runOnMachineFunction(MF);
    return true;
  }

  SDNode *Select(SDNode *N) override;

  // Complex pattern selectors
  bool SelectAddrZP(SDValue N, SDValue &Addr);
  bool SelectAddrAbs(SDValue N, SDValue &Addr);
  bool SelectAddrAbsL(SDValue N, SDValue &Addr);
  bool SelectAddrRR(SDValue N, SDValue &R1, SDValue &R2);
  bool SelectAddrRI(SDValue N, SDValue &Base, SDValue &Offset);
  bool SelectAddrRRF(SDValue N, SDValue &R1, SDValue &R2);
  bool SelectAddrRIF(SDValue N, SDValue &Base, SDValue &Offset);
  bool SelectAddrS(SDValue N, SDValue &Index, SDValue &Offset);

  /// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
  /// inline asm expressions.
  ///
  bool SelectInlineAsmMemoryOperand(const SDValue &Op,
                                    unsigned ConstraintID,
                                    std::vector<SDValue> &OutOps) override;

  // Include the pieces autogenerated from the target description.
#include "C65GenDAGISel.inc"
};
}  // end anonymous namespace

/// Select address for imm8+S
///
bool C65DAGToDAGISel::SelectAddrS(SDValue Addr, SDValue &Index,
                                  SDValue &Offset) {
  // Allow only frame indices with S indexing
  FrameIndexSDNode *FIN = nullptr;
  if ((FIN = dyn_cast<FrameIndexSDNode>(Addr))) {
    Index = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i8);
    return true;
  }
  if (Addr.getOpcode() == ISD::ADD) {
    ConstantSDNode *CN = nullptr;
    if ((FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) &&
        (CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) &&
        (isUInt<8>(CN->getZExtValue()))) {
      // Constant positive word offset from frame index
      Index = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
      Offset = CurDAG->getTargetConstant(CN->getZExtValue(), SDLoc(Addr),
                                         MVT::i8);
      return true;
    }
  }
  return false;
}

/// Select address for zero page, imm8
///
bool C65DAGToDAGISel::SelectAddrZP(SDValue Addr, SDValue &Offset) {
  if (Addr.getOpcode() != ISD::Constant) {
    // Assume that non-constants won't fit into 8 bits.
  } else if (Subtarget->has65802()) {
    // Avoid using direct page addressing for 65802.
  } else {
    uint64_t Val = cast<ConstantSDNode>(Addr)->getZExtValue();
    if (!isUInt<8>(Val)) {
      // Let 16-bit or 24-bit addressing capture this.
    } else {
      Offset = CurDAG->getTargetConstant(Val, SDLoc(Addr), MVT::i16);
      return true;
    }
  }
  return false;
}

/// Select address for absolute, imm16
///
bool C65DAGToDAGISel::SelectAddrAbs(SDValue Addr, SDValue &Offset) {
  if (Addr.getOpcode() == ISD::Constant) {
    uint64_t Val = cast<ConstantSDNode>(Addr)->getZExtValue();
    if (!Subtarget->has65802() && isUInt<8>(Val)) {
      // Let zero-page addressing capture this.
    } else if (!isUInt<16>(Val)) {
      // Address does not fit.
    } else {
      Offset = CurDAG->getTargetConstant(Val, SDLoc(Addr), MVT::i16);
      return true;
    }
  } else if (Addr.getOpcode() == C65ISD::Wrapper) {
    SDValue N = Addr.getOperand(0);
    if (N->getOpcode() != ISD::TargetConstantPool &&
        N->getOpcode() != ISD::TargetJumpTable &&
        N->getOpcode() != ISD::TargetGlobalAddress &&
        N->getOpcode() != ISD::TargetExternalSymbol &&
        N->getOpcode() != ISD::TargetBlockAddress) {
      llvm_unreachable("Unhandled wrapped node.");
    }
    Offset = N;
    return true;
  }
  return false;
}

/// Select address for long absolute, imm24
///
bool C65DAGToDAGISel::SelectAddrAbsL(SDValue Addr, SDValue &Offset) {
  if (Addr.getOpcode() == ISD::Constant) {
    uint64_t Val = cast<ConstantSDNode>(Addr)->getZExtValue();
    if (isUInt<16>(Val)) {
      // Let 16-bit immediate addressing capture this.
    } else if (!isUInt<24>(Val)) {
      // Address does not fit.
    } else {
      Offset = CurDAG->getTargetConstant(Val, SDLoc(Addr), MVT::i32);
      return true;
    }
  } else if (Addr.getOpcode() == C65ISD::FarWrapper) {
    SDValue N = Addr.getOperand(0);
    if (N->getOpcode() != ISD::TargetConstantPool &&
        N->getOpcode() != ISD::TargetJumpTable &&
        N->getOpcode() != ISD::TargetGlobalAddress &&
        N->getOpcode() != ISD::TargetExternalSymbol &&
        N->getOpcode() != ISD::TargetBlockAddress) {
      llvm_unreachable("Unhandled wrapped far node.");
    }
    Offset = N;
    return true;
  }
  return false;
}

/// Select address for reg16 + imm16
///
bool C65DAGToDAGISel::SelectAddrRI(SDValue Addr, SDValue &Base,
                                   SDValue &Offset) {
  if (Addr.getSimpleValueType() == MVT::i32) {
      // Let SelectAddrRIF capture this.
  } else if (Addr.getOpcode() == ISD::ADD) {
    SDValue N0 = Addr.getOperand(0);
    SDValue N1 = Addr.getOperand(1);
    if (N0.getOpcode() == ISD::FrameIndex) {
      // Let stack addressing mode capture this.
    } else if (N1.getOpcode() == ISD::Constant) {
      uint64_t Val = cast<ConstantSDNode>(N1)->getZExtValue();
      if (isUInt<16>(Val)) {
        Offset = CurDAG->getTargetConstant(Val, SDLoc(Addr), MVT::i16);
        Base = N0;
        return true;
      }
    }
  } else if (Addr.getOpcode() == ISD::Constant ||
             Addr.getOpcode() == C65ISD::Wrapper ||
             Addr.getOpcode() == C65ISD::FarWrapper) {
    // Let zp, abs or absl addressing mode capture this.
  } else {
    // There is currently no single-register addressing mode without
    // an offset, so handle this by having a zero offset.
    Base = Addr;
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i16);
    return true;
  }
  return false;
}

/// Select address for reg16 + reg16
///
bool C65DAGToDAGISel::SelectAddrRR(SDValue Addr, SDValue &R1,
                                   SDValue &R2) {
  if (Addr.getSimpleValueType() == MVT::i32) {
    // Let SelectAddrRRF handle this.
  } else if (Addr.getOpcode() == ISD::ADD) {
    SDValue N0 = Addr.getOperand(0);
    SDValue N1 = Addr.getOperand(1);
    ConstantSDNode *CN = nullptr;
    if (N0.getOpcode() == ISD::FrameIndex &&
        (CN = dyn_cast<ConstantSDNode>(N1)) &&
        isUInt<8>(CN->getZExtValue())) {
      // Let stack addressing mode capture this.
    } else if (N1.getOpcode() == ISD::Constant) {
      // Constant offset, let reg16 + imm16 capture this.
    } else {
      R1 = N0;
      R2 = N1;
      return true;
    }
  }
  return false;
}

/// Select address for reg32 + imm16
///
bool C65DAGToDAGISel::SelectAddrRIF(SDValue Addr, SDValue &Base,
                                    SDValue &Offset) {
  if (Addr.getSimpleValueType() != MVT::i32) {
    // Let SelectAddrRI handle this.
  } else if (Addr.getOpcode() == ISD::ADD) {
    SDValue N0 = Addr.getOperand(0);
    SDValue N1 = Addr.getOperand(1);
    if (N0.getOpcode() == ISD::FrameIndex) {
      // Let stack addressing mode capture this.
    } else if (N1.getOpcode() == ISD::Constant) {
      uint64_t Val = cast<ConstantSDNode>(N1)->getZExtValue();
      if (isUInt<16>(Val)) {
        Base = N0;
        Offset = CurDAG->getTargetConstant(Val, SDLoc(Addr), MVT::i16);
        return true;
      } else {
        // Constant is 32-bit
        Base = Addr;
        Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i16);
        return true;
      }
    } else if (N0.getOpcode() != ISD::ZERO_EXTEND &&
               N0.getOpcode() != ISD::SIGN_EXTEND &&
               N1.getOpcode() != ISD::ZERO_EXTEND &&
               N1.getOpcode() != ISD::SIGN_EXTEND) {
      // If neither of the operands are extended from 16 bits, then
      // both operands are 32 bits and selectAddrRRF will fail. Handle
      // this case here.
      Base = Addr;
      Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i16);
      return true;
    }
  } else if (Addr.getOpcode() == ISD::Constant ||
             Addr.getOpcode() == C65ISD::Wrapper ||
             Addr.getOpcode() == C65ISD::FarWrapper) {
    // Let zp, abs or absl addressing mode capture this.
  } else {
    // There is currently no single-register addressing mode without
    // an offset, so handle this by having a zero offset.
    Base = Addr;
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i16);
    return true;
  }
  return false;
}

/// Select address for reg32 + reg16
///
bool C65DAGToDAGISel::SelectAddrRRF(SDValue Addr, SDValue &R1,
                                    SDValue &R2) {
  if (Addr.getSimpleValueType() != MVT::i32) {
    // Let SelectAddrRR handle this.
  } else if (Addr.getOpcode() == ISD::ADD) {
    SDValue N0 = Addr.getOperand(0);
    SDValue N1 = Addr.getOperand(1);
    if (N0.getOpcode() == ISD::FrameIndex) {
      // Let stack addressing mode capture this.
    } else if (N1.getOpcode() == ISD::Constant) {
      // Constant offset, let reg32 + imm16 capture this.
    } else if (N0.getOpcode() == ISD::ZERO_EXTEND ||
               N0.getOpcode() == ISD::SIGN_EXTEND) {
      // N0 is 16-bit, N1 is 32-bit.
      R1 = N1;
      R2 = N0.getOperand(0);
      return true;
    } else if (N1.getOpcode() == ISD::ZERO_EXTEND ||
               N1.getOpcode() == ISD::SIGN_EXTEND) {
      // N0 is 32-bit, N1 is 16-bit.
      R1 = N0;
      R2 = N1.getOperand(0);
      return true;
    }
  }
  return false;
}

SDNode *C65DAGToDAGISel::Select(SDNode *N) {
  //MVT NVT = N->getSimpleValueType(0);
  SDLoc DL(N);

  // If we have a custom node, we already have selected!
  if (N->isMachineOpcode()) {
    DEBUG(dbgs() << "== ";  N->dump(CurDAG); dbgs() << '\n');
    N->setNodeId(-1);
    return nullptr;
  }

  unsigned OpCode = N->getOpcode();
  switch (OpCode) {
  default: break;
  }

  SDNode *ResNode = SelectCode(N);

  DEBUG(dbgs() << "=> ";
        if (ResNode == nullptr || ResNode == N)
          N->dump(CurDAG);
        else
          ResNode->dump(CurDAG);
        dbgs() << '\n');

  return ResNode;
}

/// SelectInlineAsmMemoryOperand - Implement addressing mode selection
/// for inline asm expressions.
///
bool
C65DAGToDAGISel::SelectInlineAsmMemoryOperand(const SDValue &Op,
                                              unsigned ConstraintID,
                                              std::vector<SDValue> &OutOps) {
  // TODO
  return true;
}

/// createC65ISelDag - This pass converts a legalized DAG into a
/// SPARC-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createC65ISelDag(C65TargetMachine &TM) {
  return new C65DAGToDAGISel(TM);
}
