//===-- C65ISelDAGToDAG.cpp - A dag to dag inst selector for C65 ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the C65 target.
//
//===----------------------------------------------------------------------===//

#include "C65TargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "c65-isel-dag-to-dag"

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
/// C65DAGToDAGISel - C65 specific code to select C65 machine
/// instructions for SelectionDAG operations.
///
namespace {
class C65DAGToDAGISel : public SelectionDAGISel {
  /// Subtarget - Keep a pointer to the C65 Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  ///
  const C65Subtarget &Subtarget;
  C65TargetMachine &TM;
public:
  explicit C65DAGToDAGISel(C65TargetMachine &tm)
    : SelectionDAGISel(tm),
      Subtarget(tm.getSubtarget<C65Subtarget>()),
      TM(tm) {
  }

  SDNode *Select(SDNode *N) override;

  // Complex pattern selectors
  bool SelectAddrZP(SDValue N, SDValue &Addr);
  bool SelectAddrI(SDValue N, SDValue &Addr);
  bool SelectAddrL(SDValue N, SDValue &Addr);
  bool SelectAddrRR(SDValue N, SDValue &R1, SDValue &R2);
  bool SelectAddrRI(SDValue N, SDValue &Base, SDValue &Offset);
  bool SelectAddrS(SDValue N, SDValue &Index, SDValue &Offset);

  /// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
  /// inline asm expressions.
  ///
  bool SelectInlineAsmMemoryOperand(const SDValue &Op,
                                    char ConstraintCode,
                                    std::vector<SDValue> &OutOps) override;

  const char *getPassName() const override {
    return "C65 DAG->DAG Pattern Instruction Selection";
  }

  // Include the pieces autogenerated from the target description.
#include "C65GenDAGISel.inc"
};
}  // end anonymous namespace

/// Select address for imm8+S
///
bool C65DAGToDAGISel::SelectAddrS(SDValue Addr, SDValue &Index,
                                  SDValue &Offset) {
  // Allow only frame indices with S indexing
  FrameIndexSDNode *FIN = nullptr;
  if ((FIN = dyn_cast<FrameIndexSDNode>(Addr))) {
    Index = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
    Offset = CurDAG->getTargetConstant(0, MVT::i8);
    return true;
  }
  if (Addr.getOpcode() == ISD::ADD) {
    ConstantSDNode *CN = nullptr;
    if ((FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) &&
        (CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) &&
        (isInt<8>(CN->getSExtValue()))) {
      // Constant positive word offset from frame index
      Index = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
      Offset = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i8);
      return true;
    }
  }
  return false;
}

/// Select address for zero page, imm8
///
bool C65DAGToDAGISel::SelectAddrZP(SDValue Addr, SDValue &Offset) {
  if (Addr.getOpcode() != ISD::Constant) {
    // Assume that non-constants won't fit into 8 bits.
  } else if (Subtarget.has65802()) {
    // Avoid using direct page addressing for 65802.
  } else {
    uint64_t Val = cast<ConstantSDNode>(Addr)->getSExtValue();
    if (!isInt<8>(Val)) {
      // Let 16-bit addressing capture this.
    } else {
      Offset = CurDAG->getTargetConstant(Val, MVT::i16);
      return true;
    }
  }
  return false;
}

/// Select address for absolute, imm16
///
bool C65DAGToDAGISel::SelectAddrI(SDValue Addr, SDValue &Offset) {
  if (Addr.getOpcode() == ISD::Constant) {
    uint64_t Val = cast<ConstantSDNode>(Addr)->getSExtValue();
    if (!Subtarget.has65802() && isInt<8>(Val)) {
      // Let zero-page addressing capture this.
    } else if (!isInt<16>(Val)) {
      // Address does not fit.
    } else {
      Offset = CurDAG->getTargetConstant(Val, MVT::i16);
      return true;
    }
  } else if (Addr.getOpcode() == C65ISD::Wrapper) {
    SDValue N = Addr.getOperand(0);
    if (N->getOpcode() != ISD::TargetConstantPool &&
        N->getOpcode() != ISD::TargetJumpTable &&
        N->getOpcode() != ISD::TargetGlobalAddress &&
        N->getOpcode() != ISD::TargetExternalSymbol &&
        N->getOpcode() != ISD::TargetBlockAddress) {
      llvm_unreachable("Unhandled wrapped node.");
    }
    Offset = N;
    return true;
  }
  return false;
}

/// Select address for long absolute, imm24
///
bool C65DAGToDAGISel::SelectAddrL(SDValue Addr, SDValue &Offset) {
  // TODO
  return false;
}

/// Select address for reg16 + imm16
///
bool C65DAGToDAGISel::SelectAddrRI(SDValue Addr, SDValue &Base,
                                   SDValue &Offset) {
  if (Addr.getOpcode() == ISD::ADD) {
    SDValue N0 = Addr.getOperand(0);
    SDValue N1 = Addr.getOperand(1);
    if (N0.getOpcode() == ISD::FrameIndex) {
      // Let stack addressing mode capture this.
    } else if (N1.getOpcode() == ISD::Constant) {
      uint64_t Val = cast<ConstantSDNode>(N1)->getSExtValue();
      if (isInt<16>(Val)) {
        Base = N0;
        Offset = CurDAG->getTargetConstant(Val, MVT::i16);
        return true;
      }
    } else if (N1.getOpcode() == C65ISD::Wrapper) {
      N1 = N1.getOperand(0);
      if (N1->getOpcode() != ISD::TargetConstantPool &&
          N1->getOpcode() != ISD::TargetJumpTable &&
          N1->getOpcode() != ISD::TargetGlobalAddress &&
          N1->getOpcode() != ISD::TargetExternalSymbol &&
          N1->getOpcode() != ISD::TargetBlockAddress) {
        llvm_unreachable("Unhandled wrapped node.");
      }
      Base = N0;
      Offset = N1;
      return true;
    }
  } else if (Addr.getOpcode() == ISD::Constant ||
             Addr.getOpcode() == C65ISD::Wrapper) {
    // Let zp or i16 addressing mode capture this.
  } else {
    // There is currently no single-register addressing mode without
    // an offset, so handle this by having a zero offset.
    Base = Addr;
    Offset = CurDAG->getTargetConstant(0, MVT::i16);
    return true;
  }
  return false;
}

/// Select address for reg16 + reg16
///
bool C65DAGToDAGISel::SelectAddrRR(SDValue Addr, SDValue &R1,
                                   SDValue &R2) {
  if (Addr.getOpcode() == ISD::ADD) {
    SDValue N0 = Addr.getOperand(0);
    SDValue N1 = Addr.getOperand(1);
    if (N0.getOpcode() == ISD::FrameIndex) {
      // Let stack addressing mode capture this.
    } else if (N1.getOpcode() == ISD::Constant) {
      // Constant offset, let reg16 + imm16 capture this.
    } else {
      R1 = Addr.getOperand(0);
      R2 = Addr.getOperand(1);
      return true;
    }
  }
  return false;
}

SDNode *C65DAGToDAGISel::Select(SDNode *N) {
  MVT NVT = N->getSimpleValueType(0);
  SDLoc DL(N);

  // If we have a custom node, we already have selected!
  if (N->isMachineOpcode()) {
    DEBUG(dbgs() << "== ";  N->dump(CurDAG); dbgs() << '\n');
    N->setNodeId(-1);
    return nullptr;
  }

  unsigned OpCode = N->getOpcode();
  switch (OpCode) {
  default: break;
  }

  SDNode *ResNode = SelectCode(N);

  DEBUG(dbgs() << "=> ";
        if (ResNode == nullptr || ResNode == N)
          N->dump(CurDAG);
        else
          ResNode->dump(CurDAG);
        dbgs() << '\n');

  return ResNode;
}

/// SelectInlineAsmMemoryOperand - Implement addressing mode selection
/// for inline asm expressions.
///
bool
C65DAGToDAGISel::SelectInlineAsmMemoryOperand(const SDValue &Op,
                                              char ConstraintCode,
                                              std::vector<SDValue> &OutOps) {
  // TODO
  return true;
}

/// createC65ISelDag - This pass converts a legalized DAG into a
/// SPARC-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createC65ISelDag(C65TargetMachine &TM) {
  return new C65DAGToDAGISel(TM);
}
